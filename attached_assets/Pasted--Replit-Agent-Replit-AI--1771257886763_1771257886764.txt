Ниже – вариант технического задания в форме промпта для Replit Agent / Replit AI, нацеленный на разработку многопользовательского веб‑сервиса электронной очереди студентов, при этом одновременно активна только одна очередь.
​
​

Техническое задание для Replit
1. Общая постановка
Нужно разработать многопользовательский веб‑сервис «электронная очередь студентов на защиту лабораторных/практических работ у преподавателя».
​
Приложение разворачивается как один репл (backend + web‑страница фронтенда) на Replit.
​

Основная идея:

существует одна активная очередь на защиту в текущий момент времени (глобальное ограничение: одновременно активна только одна очередь);

преподаватель запускает/останавливает очередь, вызывает следующего студента;

студенты записываются в очередь, смотрят своё положение и получают оповещение о вызове.
​

2. Технологический стек
Пожалуйста, создай приложение в одном репле на Replit со следующим стеком:

Backend: Python + Flask (или FastAPI, но предпочтителен Flask как более простой для учебного примера).

Хранение данных: простая база (SQLite) через SQLAlchemy или встроенный sqlite3.

Frontend: HTML + CSS + минимальный JavaScript (без тяжелых фреймворков, достаточно простых форм и периодического опроса статуса очереди через fetch/XHR).

Конфигурация Replit: .replit c запуском python main.py и web‑режимом (прослушивание 0.0.0.0:8080).

3. Модель предметной области и данные
3.1. Пользователи и роли
Пользователь идентифицируется по ISU ID, который одновременно является username в системе (для простоты можно реализовать «логин» через ввод ISU ID и выбор роли).
​

Две роли:

teacher – преподаватель (организует очередь);

student – студент.
​

Аутентификация может быть упрощённой (без паролей): достаточно выбора роли и ввода ISU ID, который сохраняется в сессии (cookie‑сессия Flask).
​

3.2. Очередь
Модель очереди (таблица queue + queue_item):

Очередь:

id;

is_active (bool);

discipline_name (строка);

work_name (строка, например «ЛР №3»);

created_at (время создания/старта очереди);

paused (bool – временная остановка обслуживания);

finished_at (время завершения очереди, если она завершена).
​

Элемент очереди (студент в очереди):

id;

queue_id (ссылка на очередь);

student_isu_id;

position (порядковый номер в очереди);

status (например: waiting, called, servicing, done, skipped);

requested_at (время записи в очередь);

service_start_at (время начала обслуживания – когда преподаватель вызвал студента);

service_end_at (время окончания обслуживания).
​

Требование: в базе в каждый момент времени максимум одна запись очереди с is_active = True.
​

4. Функции для ролей
4.1. Функции преподавателя (teacher)
Доступ через отдельный интерфейс (например, /teacher):
​

Запуск очереди:

Форма создания новой очереди: ввод discipline_name, work_name.

При запуске:

если уже есть активная очередь – запретить запуск новой и показать сообщение об ошибке;

создать новую запись в таблице queue с is_active = True, created_at = now, paused = False, finished_at = NULL.
​

Вызов следующего студента:

Кнопка «Вызвать следующего»:

найти в активной очереди первого студента в статусе waiting (минимальный position);

если такой студент есть:

всем другим студентам ничего не менять;

выбранному студенту установить status = called (или servicing) и service_start_at = now;

в интерфейсе преподавателя показать, кого сейчас вызывают (ISU ID, позиция, время начала обслуживания);

если студентов больше нет, можно показать «Очередь пуста».
​

Временная остановка обслуживания:

Переключатель/кнопка «Пауза»:

поле paused в очереди: True или False;

если очередь на паузе, новые вызовы не выполняются и студентам показывается, что обслуживание приостановлено.
​

Досрочное завершение очереди:

Кнопка «Завершить очередь»:

устанавливает is_active = False, finished_at = now;

после этого студенты не могут записаться в эту очередь и запросы статуса показывают, что очередь завершена.
​

Просмотр состояния очереди:

Страница со списком студентов: позиция, ISU ID, статус, время начала/окончания обслуживания;

Показ текущих агрегатов:

количество студентов в очереди;

число обслуженных;

среднее время обслуживания одного студента (по всем service_start_at/service_end_at, где они не NULL).
​

4.2. Функции студента (student)
Доступ через отдельный интерфейс (например, /student):
​

Запись в очередь:

Форма: ввод ISU ID (если не лежит уже в сессии), кнопка «Записаться».

Проверки:

есть ли активная очередь; если нет – сообщение «Очередь не запущена»;

не записан ли студент в эту очередь уже (по student_isu_id и queue_id); если записан – сообщение и вывод текущего статуса;

При успешной записи:

создать queue_item с status = waiting, requested_at = now, position = 1 + max(position);
​

показать подтверждение с текущей позицией и оценкой времени ожидания (см. ниже).

Запрос статуса:

Форма/кнопка «Мой статус»:

по ISU ID найти элемент очереди в текущей активной очереди;

если найден – вывести:

позицию в очереди (количество студентов со статусом waiting перед ним);

его текущий статус (waiting, called, servicing, done и т.п.);

оценку ожидаемого времени до вызова/до конца очереди;
​

если не найден – сообщение «Вы не записаны в текущую очередь».

Информирование о вызове:

При статусе called или servicing студент должен явно видеть, что он вызван (например, при периодическом обновлении страницы раз в N секунд).
​

Можно реализовать автообновление через JavaScript setInterval и запросы к API (например, /api/my_status).

Просмотр общей информации:

Количество людей в очереди;

Среднее время обслуживания;

Оценка времени ожидания для текущего студента.
​

5. Общие функции
Фиксация времени:

created_at для очереди (старт);

service_start_at и service_end_at для каждого студента.
​

Вычисление среднего времени обслуживания:

На основе всех записей, где service_start_at и service_end_at заполнены, рассчитать среднее service_end_at - service_start_at.

Учёт пауз можно реализовать упрощённо – без сложной коррекции: достаточно считать фактические времена обслуживания; либо игнорировать паузы для первой версии.
​

Оценка времени ожидания студента:

Для студента в статусе waiting:

оценка = (число студентов перед ним в статусах waiting или servicing) × (среднее время обслуживания).

Выводить оценку в минутах (округлить).
​

Оценка времени до завершения очереди:

Оценка = (число всех ещё не обслуженных студентов в очереди) × (среднее время обслуживания).

Ограничение на одну активную очередь:

На уровне базы и логики:

при создании новой очереди проверять отсутствие активных (is_active = True);

дополнительно можно ввести уникальное ограничение или триггер, но достаточно логики приложения для учебного примера.
​

6. Интерфейс
6.1. Общие требования
Интерфейс – простая веб‑страница, адаптированная под настольный браузер, без сложной вёрстки.

На главной странице – выбор роли: «Я преподаватель» / «Я студент».

Далее – соответствующие разделы.
​

6.2. Интерфейс преподавателя
Формы:

запуск новой очереди (название дисциплины, название работы);

кнопка «Пауза/Возобновить обслуживание»;

кнопка «Вызвать следующего студента»;

кнопка «Завершить очередь».

Таблица текущей очереди:

позиция;

ISU ID студента;

статус;

время начала/окончания обслуживания.

6.3. Интерфейс студента
Форма «Войти» (ввести ISU ID, указать, что он студент – можно ради простоты через radio‑кнопку «Я студент»).

Страница:

кнопка «Записаться в очередь»;

кнопка «Мой статус» (или автоматическое обновление блока статуса);

отображение:

текущая позиция;

статус («ожидает», «вызван», «обслуживается», «обслужен»);

оценочное время ожидания;

количество людей в очереди и оценка времени до окончания очереди.
​

7. API (предложение по структуре)
Реализовать JSON‑API (Flask endpoints), которые вызывает фронтенд через fetch:
​

POST /api/login – установить ISU ID и роль в сессии.

POST /api/queue/start (teacher) – запустить очередь.

POST /api/queue/pause (teacher) – переключить паузу.

POST /api/queue/next (teacher) – вызвать следующего студента.

POST /api/queue/finish (teacher) – завершить очередь.

GET /api/queue/status – вернуть состояние активной очереди (для teacher UI).

POST /api/queue/enqueue (student) – записаться в очередь.

GET /api/queue/my_status (student) – статус текущего студента.

Авторизацию по ролям можно делать через проверку значения в сессии: если роль не teacher, возвращать ошибку 403 для преподавательских методов.

8. Требования к коду и структуре репозитория
Файлы:

main.py – точка входа приложения, создание Flask‑приложения, маршруты;

models.py или встроенная модель в main.py (для упрощения можно всё держать в main.py, но лучше вынести);

templates/*.html – шаблоны Jinja2 для страниц teacher/student;

static/* – CSS/JS.

В .replit прописать запуск:

run = "python3 main.py".

Добавить короткий README.md с описанием того, как запустить приложение и что оно делает (для экспериментов и тестов).
​

9. Тестирование и опытная эксплуатация
Реализовать минимальный набор ручных тестов (можно описать в README):

сценарий для преподавателя: запуск очереди → несколько вызовов → пауза → возобновление → завершение;

сценарий для двух–трёх студентов: запись → проверка позиции → вызов → окончание обслуживания.

Приложение должно корректно обрабатывать ситуацию, когда студент пытается записаться при отсутствии активной очереди либо повторно записаться в ту же очередь.
​